(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./shoe\"}\n//@ sourceURL=/package.json"
));

require.define("/shoe.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar shoe = require('shoe')\n\nmodule.exports = require('./inject')(function (){\n  var args = [].slice.call(arguments)\n  return shoe.apply(null, args)\n})\n\n//@ sourceURL=/shoe.js"
));

require.define("/node_modules/shoe/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"browser.js\"}\n//@ sourceURL=/node_modules/shoe/package.json"
));

require.define("/node_modules/shoe/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar sockjs = require('sockjs-client');\n\nmodule.exports = function (uri, cb) {\n    if (/^\\/\\/[^\\/]+\\//.test(uri)) {\n        uri = window.location.protocol + uri;\n    }\n    else if (!/^https?:\\/\\//.test(uri)) {\n        uri = window.location.protocol + '//'\n            + window.location.host\n            + (/^\\//.test(uri) ? uri : '/' + uri)\n        ;\n    }\n    \n    var stream = new Stream;\n    stream.readable = true;\n    stream.writable = true;\n    \n    var ready = false;\n    var buffer = [];\n    \n    var sock = sockjs(uri);\n    stream.sock = sock;\n    \n    stream.write = function (msg) {\n        if (!ready || buffer.length) buffer.push(msg)\n        else sock.send(msg)\n    };\n    stream.end = function (msg) {\n        if (msg !== undefined) stream.write(msg);\n        if (!ready) {\n            stream._ended = true;\n            return;\n        }\n        stream.writable = false;\n        sock.close();\n    };\n\n    stream.destroy = function () {\n        stream._ended = true;\n        stream.writable = stream.readable = false;\n        buffer.length = 0\n        sock.close();\n    }\n    \n    sock.onopen = function () {\n        if (typeof cb === 'function') cb();\n        ready = true;\n        buffer.forEach(function (msg) {\n            sock.send(msg);\n        });\n        buffer = [];\n        stream.emit('connect')\n        if (stream._ended) stream.end();\n    };\n    sock.onmessage = function (e) {\n        stream.emit('data', e.data);\n    };\n    sock.onclose = function () {\n        stream.emit('end');\n        stream.writable = false;\n        stream.readable = false;\n    };\n    \n    return stream;\n};\n\n//@ sourceURL=/node_modules/shoe/browser.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/shoe/node_modules/sockjs-client/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"sockjs.js\"}\n//@ sourceURL=/node_modules/shoe/node_modules/sockjs-client/package.json"
));

require.define("/node_modules/shoe/node_modules/sockjs-client/sockjs.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License\n\nCopyright (c) 2011-2012 VMware, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// JSON2 by Douglas Crockford (minified).\nvar JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n\n\n//     [*] Including lib/index.js\n// Public object\nvar SockJS = (function(){\n              var _document = document;\n              var _window = window;\n              var utils = {};\n\n\n//         [*] Including lib/reventtarget.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n/* Simplified implementation of DOM2 EventTarget.\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n */\nvar REventTarget = function() {};\nREventTarget.prototype.addEventListener = function (eventType, listener) {\n    if(!this._listeners) {\n         this._listeners = {};\n    }\n    if(!(eventType in this._listeners)) {\n        this._listeners[eventType] = [];\n    }\n    var arr = this._listeners[eventType];\n    if(utils.arrIndexOf(arr, listener) === -1) {\n        arr.push(listener);\n    }\n    return;\n};\n\nREventTarget.prototype.removeEventListener = function (eventType, listener) {\n    if(!(this._listeners && (eventType in this._listeners))) {\n        return;\n    }\n    var arr = this._listeners[eventType];\n    var idx = utils.arrIndexOf(arr, listener);\n    if (idx !== -1) {\n        if(arr.length > 1) {\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );\n        } else {\n            delete this._listeners[eventType];\n        }\n        return;\n    }\n    return;\n};\n\nREventTarget.prototype.dispatchEvent = function (event) {\n    var t = event.type;\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (this['on'+t]) {\n        this['on'+t].apply(this, args);\n    }\n    if (this._listeners && t in this._listeners) {\n        for(var i=0; i < this._listeners[t].length; i++) {\n            this._listeners[t][i].apply(this, args);\n        }\n    }\n};\n//         [*] End of lib/reventtarget.js\n\n\n//         [*] Including lib/simpleevent.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SimpleEvent = function(type, obj) {\n    this.type = type;\n    if (typeof obj !== 'undefined') {\n        for(var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            this[k] = obj[k];\n        }\n    }\n};\n\nSimpleEvent.prototype.toString = function() {\n    var r = [];\n    for(var k in this) {\n        if (!this.hasOwnProperty(k)) continue;\n        var v = this[k];\n        if (typeof v === 'function') v = '[function]';\n        r.push(k + '=' + v);\n    }\n    return 'SimpleEvent(' + r.join(', ') + ')';\n};\n//         [*] End of lib/simpleevent.js\n\n\n//         [*] Including lib/eventemitter.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventEmitter = function(events) {\n    this.events = events || [];\n};\nEventEmitter.prototype.emit = function(type) {\n    var that = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!that.nuked && that['on'+type]) {\n        that['on'+type].apply(that, args);\n    }\n    if (utils.arrIndexOf(that.events, type) === -1) {\n        utils.log('Event ' + JSON.stringify(type) +\n                  ' not listed ' + JSON.stringify(that.events) +\n                  ' in ' + that);\n    }\n};\n\nEventEmitter.prototype.nuke = function(type) {\n    var that = this;\n    that.nuked = true;\n    for(var i=0; i<that.events.length; i++) {\n        delete that[that.events[i]];\n    }\n};\n//         [*] End of lib/eventemitter.js\n\n\n//         [*] Including lib/utils.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\nutils.random_string = function(length, max) {\n    max = max || random_string_chars.length;\n    var i, ret = [];\n    for(i=0; i < length; i++) {\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );\n    }\n    return ret.join('');\n};\nutils.random_number = function(max) {\n    return Math.floor(Math.random() * max);\n};\nutils.random_number_string = function(max) {\n    var t = (''+(max - 1)).length;\n    var p = Array(t+1).join('0');\n    return (p + utils.random_number(max)).slice(-t);\n};\n\n// Assuming that url looks like: http://asdasd:111/asd\nutils.getOrigin = function(url) {\n    url += '/';\n    var parts = url.split('/').slice(0, 3);\n    return parts.join('/');\n};\n\nutils.isSameOriginUrl = function(url_a, url_b) {\n    // location.origin would do, but it's not always available.\n    if (!url_b) url_b = _window.location.href;\n\n    return (url_a.split('/').slice(0,3).join('/')\n                ===\n            url_b.split('/').slice(0,3).join('/'));\n};\n\nutils.getParentDomain = function(url) {\n    // ipv4 ip address\n    if (/^[0-9.]*$/.test(url)) return url;\n    // ipv6 ip address\n    if (/^\\[/.test(url)) return url;\n    // no dots\n    if (!(/[.]/.test(url))) return url;\n\n    var parts = url.split('.').slice(1);\n    return parts.join('.');\n};\n\nutils.objectExtend = function(dst, src) {\n    for(var k in src) {\n        if (src.hasOwnProperty(k)) {\n            dst[k] = src[k];\n        }\n    }\n    return dst;\n};\n\nvar WPrefix = '_jp';\n\nutils.polluteGlobalNamespace = function() {\n    if (!(WPrefix in _window)) {\n        _window[WPrefix] = {};\n    }\n};\n\nutils.closeFrame = function (code, reason) {\n    return 'c'+JSON.stringify([code, reason]);\n};\n\nutils.userSetCode = function (code) {\n    return code === 1000 || (code >= 3000 && code <= 4999);\n};\n\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n// and RFC 2988.\nutils.countRTO = function (rtt) {\n    var rto;\n    if (rtt > 100) {\n        rto = 3 * rtt; // rto > 300msec\n    } else {\n        rto = rtt + 200; // 200msec < rto <= 300msec\n    }\n    return rto;\n}\n\nutils.log = function() {\n    if (_window.console && console.log && console.log.apply) {\n        console.log.apply(console, arguments);\n    }\n};\n\nutils.bind = function(fun, that) {\n    if (fun.bind) {\n        return fun.bind(that);\n    } else {\n        return function() {\n            return fun.apply(that, arguments);\n        };\n    }\n};\n\nutils.flatUrl = function(url) {\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;\n};\n\nutils.amendUrl = function(url) {\n    var dl = _document.location;\n    if (!url) {\n        throw new Error('Wrong url for SockJS');\n    }\n    if (!utils.flatUrl(url)) {\n        throw new Error('Only basic urls are supported in SockJS');\n    }\n\n    //  '//abc' --> 'http://abc'\n    if (url.indexOf('//') === 0) {\n        url = dl.protocol + url;\n    }\n    // '/abc' --> 'http://localhost:80/abc'\n    if (url.indexOf('/') === 0) {\n        url = dl.protocol + '//' + dl.host + url;\n    }\n    // strip trailing slashes\n    url = url.replace(/[/]+$/,'');\n    return url;\n};\n\n// IE doesn't support [].indexOf.\nutils.arrIndexOf = function(arr, obj){\n    for(var i=0; i < arr.length; i++){\n        if(arr[i] === obj){\n            return i;\n        }\n    }\n    return -1;\n};\n\nutils.arrSkip = function(arr, obj) {\n    var idx = utils.arrIndexOf(arr, obj);\n    if (idx === -1) {\n        return arr.slice();\n    } else {\n        var dst = arr.slice(0, idx);\n        return dst.concat(arr.slice(idx+1));\n    }\n};\n\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\nutils.isArray = Array.isArray || function(value) {\n    return {}.toString.call(value).indexOf('Array') >= 0\n};\n\nutils.delay = function(t, fun) {\n    if(typeof t === 'function') {\n        fun = t;\n        t = 0;\n    }\n    return setTimeout(fun, t);\n};\n\n\n// Chars worth escaping, as defined by Douglas Crockford:\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};\n\n// Some extra characters that Chrome gets wrong, and substitutes with\n// something else on the wire.\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;\n\n// JSON Quote string. Use native implementation when possible.\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {\n    json_escapable.lastIndex = 0;\n    if (json_escapable.test(string)) {\n        string = string.replace(json_escapable, function(a) {\n            return json_lookup[a];\n        });\n    }\n    return '\"' + string + '\"';\n};\n\n// This may be quite slow, so let's delay until user actually uses bad\n// characters.\nvar unroll_lookup = function(escapable) {\n    var i;\n    var unrolled = {}\n    var c = []\n    for(i=0; i<65536; i++) {\n        c.push( String.fromCharCode(i) );\n    }\n    escapable.lastIndex = 0;\n    c.join('').replace(escapable, function (a) {\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        return '';\n    });\n    escapable.lastIndex = 0;\n    return unrolled;\n};\n\n// Quote string, also taking care of unicode characters that browsers\n// often break. Especially, take care of unicode surrogates:\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\nutils.quote = function(string) {\n    var quoted = JSONQuote(string);\n\n    // In most cases this should be very fast and good enough.\n    extra_escapable.lastIndex = 0;\n    if(!extra_escapable.test(quoted)) {\n        return quoted;\n    }\n\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\n\n    return quoted.replace(extra_escapable, function(a) {\n        return extra_lookup[a];\n    });\n}\n\nvar _all_protocols = ['websocket',\n                      'xdr-streaming',\n                      'xhr-streaming',\n                      'iframe-eventsource',\n                      'iframe-htmlfile',\n                      'xdr-polling',\n                      'xhr-polling',\n                      'iframe-xhr-polling',\n                      'jsonp-polling'];\n\nutils.probeProtocols = function() {\n    var probed = {};\n    for(var i=0; i<_all_protocols.length; i++) {\n        var protocol = _all_protocols[i];\n        // User can have a typo in protocol name.\n        probed[protocol] = SockJS[protocol] &&\n                           SockJS[protocol].enabled();\n    }\n    return probed;\n};\n\nutils.detectProtocols = function(probed, protocols_whitelist, info) {\n    var pe = {},\n        protocols = [];\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;\n    for(var i=0; i<protocols_whitelist.length; i++) {\n        var protocol = protocols_whitelist[i];\n        pe[protocol] = probed[protocol];\n    }\n    var maybe_push = function(protos) {\n        var proto = protos.shift();\n        if (pe[proto]) {\n            protocols.push(proto);\n        } else {\n            if (protos.length > 0) {\n                maybe_push(protos);\n            }\n        }\n    }\n\n    // 1. Websocket\n    if (info.websocket !== false) {\n        maybe_push(['websocket']);\n    }\n\n    // 2. Streaming\n    if (pe['xhr-streaming'] && !info.null_origin) {\n        protocols.push('xhr-streaming');\n    } else {\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-streaming');\n        } else {\n            maybe_push(['iframe-eventsource',\n                        'iframe-htmlfile']);\n        }\n    }\n\n    // 3. Polling\n    if (pe['xhr-polling'] && !info.null_origin) {\n        protocols.push('xhr-polling');\n    } else {\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-polling');\n        } else {\n            maybe_push(['iframe-xhr-polling',\n                        'jsonp-polling']);\n        }\n    }\n    return protocols;\n}\n//         [*] End of lib/utils.js\n\n\n//         [*] Including lib/dom.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// May be used by htmlfile jsonp and transports.\nvar MPrefix = '_sockjs_global';\nutils.createHook = function() {\n    var window_id = 'a' + utils.random_string(8);\n    if (!(MPrefix in _window)) {\n        var map = {};\n        _window[MPrefix] = function(window_id) {\n            if (!(window_id in map)) {\n                map[window_id] = {\n                    id: window_id,\n                    del: function() {delete map[window_id];}\n                };\n            }\n            return map[window_id];\n        }\n    }\n    return _window[MPrefix](window_id);\n};\n\n\n\nutils.attachMessage = function(listener) {\n    utils.attachEvent('message', listener);\n};\nutils.attachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.addEventListener(event, listener, false);\n    } else {\n        // IE quirks.\n        // According to: http://stevesouders.com/misc/test-postmessage.php\n        // the message gets delivered only to 'document', not 'window'.\n        _document.attachEvent(\"on\" + event, listener);\n        // I get 'window' for ie8.\n        _window.attachEvent(\"on\" + event, listener);\n    }\n};\n\nutils.detachMessage = function(listener) {\n    utils.detachEvent('message', listener);\n};\nutils.detachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.removeEventListener(event, listener, false);\n    } else {\n        _document.detachEvent(\"on\" + event, listener);\n        _window.detachEvent(\"on\" + event, listener);\n    }\n};\n\n\nvar on_unload = {};\n// Things registered after beforeunload are to be called immediately.\nvar after_unload = false;\n\nvar trigger_unload_callbacks = function() {\n    for(var ref in on_unload) {\n        on_unload[ref]();\n        delete on_unload[ref];\n    };\n};\n\nvar unload_triggered = function() {\n    if(after_unload) return;\n    after_unload = true;\n    trigger_unload_callbacks();\n};\n\n// Onbeforeunload alone is not reliable. We could use only 'unload'\n// but it's not working in opera within an iframe. Let's use both.\nutils.attachEvent('beforeunload', unload_triggered);\nutils.attachEvent('unload', unload_triggered);\n\nutils.unload_add = function(listener) {\n    var ref = utils.random_string(8);\n    on_unload[ref] = listener;\n    if (after_unload) {\n        utils.delay(trigger_unload_callbacks);\n    }\n    return ref;\n};\nutils.unload_del = function(ref) {\n    if (ref in on_unload)\n        delete on_unload[ref];\n};\n\n\nutils.createIframe = function (iframe_url, error_callback) {\n    var iframe = _document.createElement('iframe');\n    var tref, unload_ref;\n    var unattach = function() {\n        clearTimeout(tref);\n        // Explorer had problems with that.\n        try {iframe.onload = null;} catch (x) {}\n        iframe.onerror = null;\n    };\n    var cleanup = function() {\n        if (iframe) {\n            unattach();\n            // This timeout makes chrome fire onbeforeunload event\n            // within iframe. Without the timeout it goes straight to\n            // onunload.\n            setTimeout(function() {\n                if(iframe) {\n                    iframe.parentNode.removeChild(iframe);\n                }\n                iframe = null;\n            }, 0);\n            utils.unload_del(unload_ref);\n        }\n    };\n    var onerror = function(r) {\n        if (iframe) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    iframe.src = iframe_url;\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.onerror = function(){onerror('onerror');};\n    iframe.onload = function() {\n        // `onload` is triggered before scripts on the iframe are\n        // executed. Give it few seconds to actually load stuff.\n        clearTimeout(tref);\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);\n    };\n    _document.body.appendChild(iframe);\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n\nutils.createHtmlfile = function (iframe_url, error_callback) {\n    var doc = new ActiveXObject('htmlfile');\n    var tref, unload_ref;\n    var iframe;\n    var unattach = function() {\n        clearTimeout(tref);\n    };\n    var cleanup = function() {\n        if (doc) {\n            unattach();\n            utils.unload_del(unload_ref);\n            iframe.parentNode.removeChild(iframe);\n            iframe = doc = null;\n            CollectGarbage();\n        }\n    };\n    var onerror = function(r)  {\n        if (doc) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    doc.open();\n    doc.write('<html><s' + 'cript>' +\n              'document.domain=\"' + document.domain + '\";' +\n              '</s' + 'cript></html>');\n    doc.close();\n    doc.parentWindow[WPrefix] = _window[WPrefix];\n    var c = doc.createElement('div');\n    doc.body.appendChild(c);\n    iframe = doc.createElement('iframe');\n    c.appendChild(iframe);\n    iframe.src = iframe_url;\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n//         [*] End of lib/dom.js\n\n\n//         [*] Including lib/dom2.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AbstractXHRObject = function(){};\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n    var that = this;\n\n    try {\n        that.xhr = new XMLHttpRequest();\n    } catch(x) {};\n\n    if (!that.xhr) {\n        try {\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\n        } catch(x) {};\n    }\n    if (_window.ActiveXObject || _window.XDomainRequest) {\n        // IE8 caches even POSTs\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n    }\n\n    // Explorer tends to keep connection open, even after the\n    // tab gets closed: http://bugs.jquery.com/ticket/5280\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        that.xhr.open(method, url, true);\n    } catch(e) {\n        // IE raises an exception on wrong port.\n        that.emit('finish', 0, '');\n        that._cleanup();\n        return;\n    };\n\n    if (!opts || !opts.no_credentials) {\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n        // \"This never affects same-site requests.\"\n        that.xhr.withCredentials = 'true';\n    }\n    if (opts && opts.headers) {\n        for(var key in opts.headers) {\n            that.xhr.setRequestHeader(key, opts.headers[key]);\n        }\n    }\n\n    that.xhr.onreadystatechange = function() {\n        if (that.xhr) {\n            var x = that.xhr;\n            switch (x.readyState) {\n            case 3:\n                // IE doesn't like peeking into responseText or status\n                // on Microsoft.XMLHTTP and readystate=3\n                try {\n                    var status = x.status;\n                    var text = x.responseText;\n                } catch (x) {};\n                // IE does return readystate == 3 for 404 answers.\n                if (text && text.length > 0) {\n                    that.emit('chunk', status, text);\n                }\n                break;\n            case 4:\n                that.emit('finish', x.status, x.responseText);\n                that._cleanup(false);\n                break;\n            }\n        }\n    };\n    that.xhr.send(payload);\n};\n\nAbstractXHRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xhr) return;\n    utils.unload_del(that.unload_ref);\n\n    // IE needs this field to be a function\n    that.xhr.onreadystatechange = function(){};\n\n    if (abort) {\n        try {\n            that.xhr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xhr = null;\n};\n\nAbstractXHRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\nvar XHRCorsObject = utils.XHRCorsObject = function() {\n    var that = this, args = arguments;\n    utils.delay(function(){that._start.apply(that, args);});\n};\nXHRCorsObject.prototype = new AbstractXHRObject();\n\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){\n        that._start(method, url, payload, {\n            no_credentials: true\n        });\n    });\n};\nXHRLocalObject.prototype = new AbstractXHRObject();\n\n\n\n// References:\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\nvar XDRObject = utils.XDRObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){that._start(method, url, payload);});\n};\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);\nXDRObject.prototype._start = function(method, url, payload) {\n    var that = this;\n    var xdr = new XDomainRequest();\n    // IE caches even POSTs\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n\n    var onerror = xdr.ontimeout = xdr.onerror = function() {\n        that.emit('finish', 0, '');\n        that._cleanup(false);\n    };\n    xdr.onprogress = function() {\n        that.emit('chunk', 200, xdr.responseText);\n    };\n    xdr.onload = function() {\n        that.emit('finish', 200, xdr.responseText);\n        that._cleanup(false);\n    };\n    that.xdr = xdr;\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        // Fails with AccessDenied if port number is bogus\n        that.xdr.open(method, url);\n        that.xdr.send(payload);\n    } catch(x) {\n        onerror();\n    }\n};\n\nXDRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xdr) return;\n    utils.unload_del(that.unload_ref);\n\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =\n        that.xdr.onload = null;\n    if (abort) {\n        try {\n            that.xdr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xdr = null;\n};\n\nXDRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\n// 1. Is natively via XHR\n// 2. Is natively via XDR\n// 3. Nope, but postMessage is there so it should work via the Iframe.\n// 4. Nope, sorry.\nutils.isXHRCorsCapable = function() {\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\n        return 1;\n    }\n    // XDomainRequest doesn't work if page is served from file://\n    if (_window.XDomainRequest && _document.domain) {\n        return 2;\n    }\n    if (IframeTransport.enabled()) {\n        return 3;\n    }\n    return 4;\n};\n//         [*] End of lib/dom2.js\n\n\n//         [*] Including lib/sockjs.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SockJS = function(url, dep_protocols_whitelist, options) {\n    if (this === window) {\n        // makes `new` optional\n        return new SockJS(url, dep_protocols_whitelist, options);\n    }\n    \n    var that = this, protocols_whitelist;\n    that._options = {devel: false, debug: false, protocols_whitelist: [],\n                     info: undefined, rtt: undefined};\n    if (options) {\n        utils.objectExtend(that._options, options);\n    }\n    that._base_url = utils.amendUrl(url);\n    that._server = that._options.server || utils.random_number_string(1000);\n    if (that._options.protocols_whitelist &&\n        that._options.protocols_whitelist.length) {\n        protocols_whitelist = that._options.protocols_whitelist;\n    } else {\n        // Deprecated API\n        if (typeof dep_protocols_whitelist === 'string' &&\n            dep_protocols_whitelist.length > 0) {\n            protocols_whitelist = [dep_protocols_whitelist];\n        } else if (utils.isArray(dep_protocols_whitelist)) {\n            protocols_whitelist = dep_protocols_whitelist\n        } else {\n            protocols_whitelist = null;\n        }\n        if (protocols_whitelist) {\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +\n                        'instead of supplying protocol list as a second ' +\n                        'parameter to SockJS constructor.');\n        }\n    }\n    that._protocols = [];\n    that.protocol = null;\n    that.readyState = SockJS.CONNECTING;\n    that._ir = createInfoReceiver(that._base_url);\n    that._ir.onfinish = function(info, rtt) {\n        that._ir = null;\n        if (info) {\n            if (that._options.info) {\n                // Override if user supplies the option\n                info = utils.objectExtend(info, that._options.info);\n            }\n            if (that._options.rtt) {\n                rtt = that._options.rtt;\n            }\n            that._applyInfo(info, rtt, protocols_whitelist);\n            that._didClose();\n        } else {\n            that._didClose(1002, 'Can\\'t connect to server', true);\n        }\n    };\n};\n// Inheritance\nSockJS.prototype = new REventTarget();\n\nSockJS.version = \"0.3.1.7.ga67f.dirty\";\n\nSockJS.CONNECTING = 0;\nSockJS.OPEN = 1;\nSockJS.CLOSING = 2;\nSockJS.CLOSED = 3;\n\nSockJS.prototype._debug = function() {\n    if (this._options.debug)\n        utils.log.apply(utils, arguments);\n};\n\nSockJS.prototype._dispatchOpen = function() {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING) {\n        if (that._transport_tref) {\n            clearTimeout(that._transport_tref);\n            that._transport_tref = null;\n        }\n        that.readyState = SockJS.OPEN;\n        that.dispatchEvent(new SimpleEvent(\"open\"));\n    } else {\n        // The server might have been restarted, and lost track of our\n        // connection.\n        that._didClose(1006, \"Server lost session\");\n    }\n};\n\nSockJS.prototype._dispatchMessage = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n            return;\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));\n};\n\nSockJS.prototype._dispatchHeartbeat = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n        return;\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));\n};\n\nSockJS.prototype._didClose = function(code, reason, force) {\n    var that = this;\n    if (that.readyState !== SockJS.CONNECTING &&\n        that.readyState !== SockJS.OPEN &&\n        that.readyState !== SockJS.CLOSING)\n            throw new Error('INVALID_STATE_ERR');\n    if (that._ir) {\n        that._ir.nuke();\n        that._ir = null;\n    }\n\n    if (that._transport) {\n        that._transport.doCleanup();\n        that._transport = null;\n    }\n\n    var close_event = new SimpleEvent(\"close\", {\n        code: code,\n        reason: reason,\n        wasClean: utils.userSetCode(code)});\n\n    if (!utils.userSetCode(code) &&\n        that.readyState === SockJS.CONNECTING && !force) {\n        if (that._try_next_protocol(close_event)) {\n            return;\n        }\n        close_event = new SimpleEvent(\"close\", {code: 2000,\n                                                reason: \"All transports failed\",\n                                                wasClean: false,\n                                                last_event: close_event});\n    }\n    that.readyState = SockJS.CLOSED;\n\n    utils.delay(function() {\n                   that.dispatchEvent(close_event);\n                });\n};\n\nSockJS.prototype._didMessage = function(data) {\n    var that = this;\n    var type = data.slice(0, 1);\n    switch(type) {\n    case 'o':\n        that._dispatchOpen();\n        break;\n    case 'a':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        for(var i=0; i < payload.length; i++){\n            that._dispatchMessage(payload[i]);\n        }\n        break;\n    case 'm':\n        var payload = JSON.parse(data.slice(1) || 'null');\n        that._dispatchMessage(payload);\n        break;\n    case 'c':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        that._didClose(payload[0], payload[1]);\n        break;\n    case 'h':\n        that._dispatchHeartbeat();\n        break;\n    }\n};\n\nSockJS.prototype._try_next_protocol = function(close_event) {\n    var that = this;\n    if (that.protocol) {\n        that._debug('Closed transport:', that.protocol, ''+close_event);\n        that.protocol = null;\n    }\n    if (that._transport_tref) {\n        clearTimeout(that._transport_tref);\n        that._transport_tref = null;\n    }\n\n    while(1) {\n        var protocol = that.protocol = that._protocols.shift();\n        if (!protocol) {\n            return false;\n        }\n        // Some protocols require access to `body`, what if were in\n        // the `head`?\n        if (SockJS[protocol] &&\n            SockJS[protocol].need_body === true &&\n            (!_document.body ||\n             (typeof _document.readyState !== 'undefined'\n              && _document.readyState !== 'complete'))) {\n            that._protocols.unshift(protocol);\n            that.protocol = 'waiting-for-load';\n            utils.attachEvent('load', function(){\n                that._try_next_protocol();\n            });\n            return true;\n        }\n\n        if (!SockJS[protocol] ||\n              !SockJS[protocol].enabled(that._options)) {\n            that._debug('Skipping transport:', protocol);\n        } else {\n            var roundTrips = SockJS[protocol].roundTrips || 1;\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;\n            that._transport_tref = utils.delay(to, function() {\n                if (that.readyState === SockJS.CONNECTING) {\n                    // I can't understand how it is possible to run\n                    // this timer, when the state is CLOSED, but\n                    // apparently in IE everythin is possible.\n                    that._didClose(2007, \"Transport timeouted\");\n                }\n            });\n\n            var connid = utils.random_string(8);\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,\n                        ' RTO:'+that._options.rto);\n            that._transport = new SockJS[protocol](that, trans_url,\n                                                   that._base_url);\n            return true;\n        }\n    }\n};\n\nSockJS.prototype.close = function(code, reason) {\n    var that = this;\n    if (code && !utils.userSetCode(code))\n        throw new Error(\"INVALID_ACCESS_ERR\");\n    if(that.readyState !== SockJS.CONNECTING &&\n       that.readyState !== SockJS.OPEN) {\n        return false;\n    }\n    that.readyState = SockJS.CLOSING;\n    that._didClose(code || 1000, reason || \"Normal closure\");\n    return true;\n};\n\nSockJS.prototype.send = function(data) {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING)\n        throw new Error('INVALID_STATE_ERR');\n    if (that.readyState === SockJS.OPEN) {\n        that._transport.doSend(utils.quote('' + data));\n    }\n    return true;\n};\n\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {\n    var that = this;\n    that._options.info = info;\n    that._options.rtt = rtt;\n    that._options.rto = utils.countRTO(rtt);\n    that._options.info.null_origin = !_document.domain;\n    var probed = utils.probeProtocols();\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);\n};\n//         [*] End of lib/sockjs.js\n\n\n//         [*] Including lib/trans-websocket.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {\n    var that = this;\n    var url = trans_url + '/websocket';\n    if (url.slice(0, 5) === 'https') {\n        url = 'wss' + url.slice(5);\n    } else {\n        url = 'ws' + url.slice(4);\n    }\n    that.ri = ri;\n    that.url = url;\n    var Constructor = _window.WebSocket || _window.MozWebSocket;\n\n    that.ws = new Constructor(that.url);\n    that.ws.onmessage = function(e) {\n        that.ri._didMessage(e.data);\n    };\n    // Firefox has an interesting bug. If a websocket connection is\n    // created after onbeforeunload, it stays alive even when user\n    // navigates away from the page. In such situation let's lie -\n    // let's not open the ws connection at all. See:\n    // https://github.com/sockjs/sockjs-client/issues/28\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});\n    that.ws.onclose = function() {\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));\n    };\n};\n\nWebSocketTransport.prototype.doSend = function(data) {\n    this.ws.send('[' + data + ']');\n};\n\nWebSocketTransport.prototype.doCleanup = function() {\n    var that = this;\n    var ws = that.ws;\n    if (ws) {\n        ws.onmessage = ws.onclose = null;\n        ws.close();\n        utils.unload_del(that.unload_ref);\n        that.unload_ref = that.ri = that.ws = null;\n    }\n};\n\nWebSocketTransport.enabled = function() {\n    return !!(_window.WebSocket || _window.MozWebSocket);\n};\n\n// In theory, ws should require 1 round trip. But in chrome, this is\n// not very stable over SSL. Most likely a ws connection requires a\n// separate SSL connection, in which case 2 round trips are an\n// absolute minumum.\nWebSocketTransport.roundTrips = 2;\n//         [*] End of lib/trans-websocket.js\n\n\n//         [*] Including lib/trans-sender.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar BufferedSender = function() {};\nBufferedSender.prototype.send_constructor = function(sender) {\n    var that = this;\n    that.send_buffer = [];\n    that.sender = sender;\n};\nBufferedSender.prototype.doSend = function(message) {\n    var that = this;\n    that.send_buffer.push(message);\n    if (!that.send_stop) {\n        that.send_schedule();\n    }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.send_schedule_wait = function() {\n    var that = this;\n    var tref;\n    that.send_stop = function() {\n        that.send_stop = null;\n        clearTimeout(tref);\n    };\n    tref = utils.delay(25, function() {\n        that.send_stop = null;\n        that.send_schedule();\n    });\n};\n\nBufferedSender.prototype.send_schedule = function() {\n    var that = this;\n    if (that.send_buffer.length > 0) {\n        var payload = '[' + that.send_buffer.join(',') + ']';\n        that.send_stop = that.sender(that.trans_url,\n                                     payload,\n                                     function() {\n                                         that.send_stop = null;\n                                         that.send_schedule_wait();\n                                     });\n        that.send_buffer = [];\n    }\n};\n\nBufferedSender.prototype.send_destructor = function() {\n    var that = this;\n    if (that._send_stop) {\n        that._send_stop();\n    }\n    that._send_stop = null;\n};\n\nvar jsonPGenericSender = function(url, payload, callback) {\n    var that = this;\n\n    if (!('_send_form' in that)) {\n        var form = that._send_form = _document.createElement('form');\n        var area = that._send_area = _document.createElement('textarea');\n        area.name = 'd';\n        form.style.display = 'none';\n        form.style.position = 'absolute';\n        form.method = 'POST';\n        form.enctype = 'application/x-www-form-urlencoded';\n        form.acceptCharset = \"UTF-8\";\n        form.appendChild(area);\n        _document.body.appendChild(form);\n    }\n    var form = that._send_form;\n    var area = that._send_area;\n    var id = 'a' + utils.random_string(8);\n    form.target = id;\n    form.action = url + '/jsonp_send?i=' + id;\n\n    var iframe;\n    try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');\n    } catch(x) {\n        iframe = _document.createElement('iframe');\n        iframe.name = id;\n    }\n    iframe.id = id;\n    form.appendChild(iframe);\n    iframe.style.display = 'none';\n\n    try {\n        area.value = payload;\n    } catch(e) {\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);\n    }\n    form.submit();\n\n    var completed = function(e) {\n        if (!iframe.onerror) return;\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n        // Opera mini doesn't like if we GC iframe\n        // immediately, thus this timeout.\n        utils.delay(500, function() {\n                       iframe.parentNode.removeChild(iframe);\n                       iframe = null;\n                   });\n        area.value = '';\n        callback();\n    };\n    iframe.onerror = iframe.onload = completed;\n    iframe.onreadystatechange = function(e) {\n        if (iframe.readyState == 'complete') completed();\n    };\n    return completed;\n};\n\nvar createAjaxSender = function(AjaxObject) {\n    return function(url, payload, callback) {\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);\n        xo.onfinish = function(status, text) {\n            callback(status);\n        };\n        return function(abort_reason) {\n            callback(0, abort_reason);\n        };\n    };\n};\n//         [*] End of lib/trans-sender.js\n\n\n//         [*] Including lib/trans-jsonp-receiver.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Parts derived from Socket.io:\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\n// and jQuery-JSONP:\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\nvar jsonPGenericReceiver = function(url, callback) {\n    var tref;\n    var script = _document.createElement('script');\n    var script2;  // Opera synchronous load trick.\n    var close_script = function(frame) {\n        if (script2) {\n            script2.parentNode.removeChild(script2);\n            script2 = null;\n        }\n        if (script) {\n            clearTimeout(tref);\n            script.parentNode.removeChild(script);\n            script.onreadystatechange = script.onerror =\n                script.onload = script.onclick = null;\n            script = null;\n            callback(frame);\n            callback = null;\n        }\n    };\n\n    // IE9 fires 'error' event after orsc or before, in random order.\n    var loaded_okay = false;\n    var error_timer = null;\n\n    script.id = 'a' + utils.random_string(8);\n    script.src = url;\n    script.type = 'text/javascript';\n    script.charset = 'UTF-8';\n    script.onerror = function(e) {\n        if (!error_timer) {\n            // Delay firing close_script.\n            error_timer = setTimeout(function() {\n                if (!loaded_okay) {\n                    close_script(utils.closeFrame(\n                        1006,\n                        \"JSONP script loaded abnormally (onerror)\"));\n                }\n            }, 1000);\n        }\n    };\n    script.onload = function(e) {\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));\n    };\n\n    script.onreadystatechange = function(e) {\n        if (/loaded|closed/.test(script.readyState)) {\n            if (script && script.htmlFor && script.onclick) {\n                loaded_okay = true;\n                try {\n                    // In IE, actually execute the script.\n                    script.onclick();\n                } catch (x) {}\n            }\n            if (script) {\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));\n            }\n        }\n    };\n    // IE: event/htmlFor/onclick trick.\n    // One can't rely on proper order for onreadystatechange. In order to\n    // make sure, set a 'htmlFor' and 'event' properties, so that\n    // script code will be installed as 'onclick' handler for the\n    // script object. Later, onreadystatechange, manually execute this\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n    // set. For reference see:\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n    // Also, read on that about script ordering:\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n    if (typeof script.async === 'undefined' && _document.attachEvent) {\n        // According to mozilla docs, in recent browsers script.async defaults\n        // to 'true', so we may use it to detect a good browser:\n        // https://developer.mozilla.org/en/HTML/Element/script\n        if (!/opera/i.test(navigator.userAgent)) {\n            // Naively assume we're in IE\n            try {\n                script.htmlFor = script.id;\n                script.event = \"onclick\";\n            } catch (x) {}\n            script.async = true;\n        } else {\n            // Opera, second sync script hack\n            script2 = _document.createElement('script');\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";\n            script.async = script2.async = false;\n        }\n    }\n    if (typeof script.async !== 'undefined') {\n        script.async = true;\n    }\n\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n    tref = setTimeout(function() {\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));\n                      }, 35000);\n\n    var head = _document.getElementsByTagName('head')[0];\n    head.insertBefore(script, head.firstChild);\n    if (script2) {\n        head.insertBefore(script2, head.firstChild);\n    }\n    return close_script;\n};\n//         [*] End of lib/trans-jsonp-receiver.js\n\n\n//         [*] Including lib/trans-jsonp-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// The simplest and most robust transport, using the well-know cross\n// domain hack - JSONP. This transport is quite inefficient - one\n// mssage could use up to one http request. But at least it works almost\n// everywhere.\n// Known limitations:\n//   o you will get a spinning cursor\n//   o for Konqueror a dumb timer is needed to detect errors\n\n\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {\n    utils.polluteGlobalNamespace();\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(jsonPGenericSender);\n    that._schedule_recv();\n};\n\n// Inheritnace\nJsonPTransport.prototype = new BufferedSender();\n\nJsonPTransport.prototype._schedule_recv = function() {\n    var that = this;\n    var callback = function(data) {\n        that._recv_stop = null;\n        if (data) {\n            // no data - heartbeat;\n            if (!that._is_closing) {\n                that.ri._didMessage(data);\n            }\n        }\n        // The message can be a close message, and change is_closing state.\n        if (!that._is_closing) {\n            that._schedule_recv();\n        }\n    };\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',\n                                           jsonPGenericReceiver, callback);\n};\n\nJsonPTransport.enabled = function() {\n    return true;\n};\n\nJsonPTransport.need_body = true;\n\n\nJsonPTransport.prototype.doCleanup = function() {\n    var that = this;\n    that._is_closing = true;\n    if (that._recv_stop) {\n        that._recv_stop();\n    }\n    that.ri = that._recv_stop = null;\n    that.send_destructor();\n};\n\n\n// Abstract away code that handles global namespace pollution.\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {\n    var id = 'a' + utils.random_string(6);\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);\n    // Callback will be called exactly once.\n    var callback = function(frame) {\n        delete _window[WPrefix][id];\n        user_callback(frame);\n    };\n\n    var close_script = constructReceiver(url_id, callback);\n    _window[WPrefix][id] = close_script;\n    var stop = function() {\n        if (_window[WPrefix][id]) {\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));\n        }\n    };\n    return stop;\n};\n//         [*] End of lib/trans-jsonp-polling.js\n\n\n//         [*] Including lib/trans-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AjaxBasedTransport = function() {};\nAjaxBasedTransport.prototype = new BufferedSender();\n\nAjaxBasedTransport.prototype.run = function(ri, trans_url,\n                                            url_suffix, Receiver, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(createAjaxSender(AjaxObject));\n    that.poll = new Polling(ri, Receiver,\n                            trans_url + url_suffix, AjaxObject);\n};\n\nAjaxBasedTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.poll) {\n        that.poll.abort();\n        that.poll = null;\n    }\n};\n\n// xhr-streaming\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXhrStreamingTransport.enabled = function() {\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\n    // doesn't do streaming.\n    return (_window.XMLHttpRequest &&\n            'withCredentials' in new XMLHttpRequest() &&\n            (!/opera/i.test(navigator.userAgent)));\n};\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n// Safari gets confused when a streaming ajax request is started\n// before onload. This causes the load indicator to spin indefinetely.\nXhrStreamingTransport.need_body = true;\n\n\n// According to:\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\n\n// xdr-streaming\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\n};\n\nXdrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXdrStreamingTransport.enabled = function() {\n    return !!_window.XDomainRequest;\n};\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n\n\n// xhr-polling\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrPollingTransport.prototype = new AjaxBasedTransport();\n\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\n\n// xdr-polling\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\n};\n\nXdrPollingTransport.prototype = new AjaxBasedTransport();\n\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\n//         [*] End of lib/trans-xhr.js\n\n\n//         [*] Including lib/trans-iframe.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Few cool transports do work only for same-origin. In order to make\n// them working cross-domain we shall use iframe, served form the\n// remote domain. New browsers, have capabilities to communicate with\n// cross domain iframe, using postMessage(). In IE it was implemented\n// from IE 8+, but of course, IE got some details wrong:\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n//    http://stevesouders.com/misc/test-postmessage.php\n\nvar IframeTransport = function() {};\n\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {\n    var that = this;\n    that.ri = ri;\n    that.origin = utils.getOrigin(base_url);\n    that.base_url = base_url;\n    that.trans_url = trans_url;\n\n    var iframe_url = base_url + '/iframe.html';\n    if (that.ri._options.devel) {\n        iframe_url += '?t=' + (+new Date);\n    }\n    that.window_id = utils.random_string(8);\n    iframe_url += '#' + that.window_id;\n\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");\n                                        });\n\n    that.onmessage_cb = utils.bind(that.onmessage, that);\n    utils.attachMessage(that.onmessage_cb);\n};\n\nIframeTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.iframeObj) {\n        utils.detachMessage(that.onmessage_cb);\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (that.iframeObj.iframe.contentWindow) {\n                that.postMessage('c');\n            }\n        } catch (x) {}\n        that.iframeObj.cleanup();\n        that.iframeObj = null;\n        that.onmessage_cb = that.iframeObj = null;\n    }\n};\n\nIframeTransport.prototype.onmessage = function(e) {\n    var that = this;\n    if (e.origin !== that.origin) return;\n    var window_id = e.data.slice(0, 8);\n    var type = e.data.slice(8, 9);\n    var data = e.data.slice(9);\n\n    if (window_id !== that.window_id) return;\n\n    switch(type) {\n    case 's':\n        that.iframeObj.loaded();\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\n        break;\n    case 't':\n        that.ri._didMessage(data);\n        break;\n    }\n};\n\nIframeTransport.prototype.postMessage = function(type, data) {\n    var that = this;\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\n};\n\nIframeTransport.prototype.doSend = function (message) {\n    this.postMessage('m', message);\n};\n\nIframeTransport.enabled = function() {\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n    // huge delay, or not at all.\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\n    return ((typeof _window.postMessage === 'function' ||\n            typeof _window.postMessage === 'object') && (!konqueror));\n};\n//         [*] End of lib/trans-iframe.js\n\n\n//         [*] Including lib/trans-iframe-within.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar curr_window_id;\n\nvar postMessage = function (type, data) {\n    if(parent !== _window) {\n        parent.postMessage(curr_window_id + type + (data || ''), '*');\n    } else {\n        utils.log(\"Can't postMessage, no parent window.\", type, data);\n    }\n};\n\nvar FacadeJS = function() {};\nFacadeJS.prototype._didClose = function (code, reason) {\n    postMessage('t', utils.closeFrame(code, reason));\n};\nFacadeJS.prototype._didMessage = function (frame) {\n    postMessage('t', frame);\n};\nFacadeJS.prototype._doSend = function (data) {\n    this._transport.doSend(data);\n};\nFacadeJS.prototype._doCleanup = function () {\n    this._transport.doCleanup();\n};\n\nutils.parent_origin = undefined;\n\nSockJS.bootstrap_iframe = function() {\n    var facade;\n    curr_window_id = _document.location.hash.slice(1);\n    var onMessage = function(e) {\n        if(e.source !== parent) return;\n        if(typeof utils.parent_origin === 'undefined')\n            utils.parent_origin = e.origin;\n        if (e.origin !== utils.parent_origin) return;\n\n        var window_id = e.data.slice(0, 8);\n        var type = e.data.slice(8, 9);\n        var data = e.data.slice(9);\n        if (window_id !== curr_window_id) return;\n        switch(type) {\n        case 's':\n            var p = JSON.parse(data);\n            var version = p[0];\n            var protocol = p[1];\n            var trans_url = p[2];\n            var base_url = p[3];\n            if (version !== SockJS.version) {\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +\n                          \" \\\"\" + version + \"\\\", the iframe:\" +\n                          \" \\\"\" + SockJS.version + \"\\\".\");\n            }\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\n                utils.log(\"Only basic urls are supported in SockJS\");\n                return;\n            }\n\n            if (!utils.isSameOriginUrl(trans_url) ||\n                !utils.isSameOriginUrl(base_url)) {\n                utils.log(\"Can't connect to different domain from within an \" +\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +\n                          \")\");\n                return;\n            }\n            facade = new FacadeJS();\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\n            break;\n        case 'm':\n            facade._doSend(data);\n            break;\n        case 'c':\n            if (facade)\n                facade._doCleanup();\n            facade = null;\n            break;\n        }\n    };\n\n    // alert('test ticker');\n    // facade = new FacadeJS();\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\n\n    utils.attachMessage(onMessage);\n\n    // Start\n    postMessage('s');\n};\n//         [*] End of lib/trans-iframe-within.js\n\n\n//         [*] Including lib/info.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar InfoReceiver = function(base_url, AjaxObject) {\n    var that = this;\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});\n};\n\nInfoReceiver.prototype = new EventEmitter(['finish']);\n\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {\n    var that = this;\n    var t0 = (new Date()).getTime();\n    var xo = new AjaxObject('GET', base_url + '/info');\n\n    var tref = utils.delay(8000,\n                           function(){xo.ontimeout();});\n\n    xo.onfinish = function(status, text) {\n        clearTimeout(tref);\n        tref = null;\n        if (status === 200) {\n            var rtt = (new Date()).getTime() - t0;\n            var info = JSON.parse(text);\n            if (typeof info !== 'object') info = {};\n            that.emit('finish', info, rtt);\n        } else {\n            that.emit('finish');\n        }\n    };\n    xo.ontimeout = function() {\n        xo.close();\n        that.emit('finish');\n    };\n};\n\nvar InfoReceiverIframe = function(base_url) {\n    var that = this;\n    var go = function() {\n        var ifr = new IframeTransport();\n        ifr.protocol = 'w-iframe-info-receiver';\n        var fun = function(r) {\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {\n                var d = JSON.parse(r.substr(1));\n                var info = d[0], rtt = d[1];\n                that.emit('finish', info, rtt);\n            } else {\n                that.emit('finish');\n            }\n            ifr.doCleanup();\n            ifr = null;\n        };\n        var mock_ri = {\n            _options: {},\n            _didClose: fun,\n            _didMessage: fun\n        };\n        ifr.i_constructor(mock_ri, base_url, base_url);\n    }\n    if(!_document.body) {\n        utils.attachEvent('load', go);\n    } else {\n        go();\n    }\n};\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);\n\n\nvar InfoReceiverFake = function() {\n    // It may not be possible to do cross domain AJAX to get the info\n    // data, for example for IE7. But we want to run JSONP, so let's\n    // fake the response, with rtt=2s (rto=6s).\n    var that = this;\n    utils.delay(function() {\n        that.emit('finish', {}, 2000);\n    });\n};\nInfoReceiverFake.prototype = new EventEmitter(['finish']);\n\nvar createInfoReceiver = function(base_url) {\n    if (utils.isSameOriginUrl(base_url)) {\n        // If, for some reason, we have SockJS locally - there's no\n        // need to start up the complex machinery. Just use ajax.\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\n    }\n    switch (utils.isXHRCorsCapable()) {\n    case 1:\n        return new InfoReceiver(base_url, utils.XHRCorsObject);\n    case 2:\n        return new InfoReceiver(base_url, utils.XDRObject);\n    case 3:\n        // Opera\n        return new InfoReceiverIframe(base_url);\n    default:\n        // IE 7\n        return new InfoReceiverFake();\n    };\n};\n\n\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\n    ir.onfinish = function(info, rtt) {\n        ri._didMessage('m'+JSON.stringify([info, rtt]));\n        ri._didClose();\n    }\n};\nWInfoReceiverIframe.prototype.doCleanup = function() {};\n//         [*] End of lib/info.js\n\n\n//         [*] Including lib/trans-iframe-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-eventsource';\n    that.i_constructor.apply(that, arguments);\n};\n\nEventSourceIframeTransport.prototype = new IframeTransport();\n\nEventSourceIframeTransport.enabled = function () {\n    return ('EventSource' in _window) && IframeTransport.enabled();\n};\n\nEventSourceIframeTransport.need_body = true;\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\n\n\n// w-iframe-eventsource\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\n}\nEventSourceTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-eventsource.js\n\n\n//         [*] Including lib/trans-iframe-xhr-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-xhr-polling';\n    that.i_constructor.apply(that, arguments);\n};\n\nXhrPollingIframeTransport.prototype = new IframeTransport();\n\nXhrPollingIframeTransport.enabled = function () {\n    return _window.XMLHttpRequest && IframeTransport.enabled();\n};\n\nXhrPollingIframeTransport.need_body = true;\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\n\n\n// w-iframe-xhr-polling\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\n};\n\nXhrPollingITransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-xhr-polling.js\n\n\n//         [*] Including lib/trans-iframe-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// This transport generally works in any browser, but will cause a\n// spinning cursor to appear in any browser other than IE.\n// We may test this transport in all browsers - why not, but in\n// production it should be only run in IE.\n\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-htmlfile';\n    that.i_constructor.apply(that, arguments);\n};\n\n// Inheritance.\nHtmlFileIframeTransport.prototype = new IframeTransport();\n\nHtmlFileIframeTransport.enabled = function() {\n    return IframeTransport.enabled();\n};\n\nHtmlFileIframeTransport.need_body = true;\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\n\n\n// w-iframe-htmlfile\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\n};\nHtmlFileTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-htmlfile.js\n\n\n//         [*] Including lib/trans-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.Receiver = Receiver;\n    that.recv_url = recv_url;\n    that.AjaxObject = AjaxObject;\n    that._scheduleRecv();\n};\n\nPolling.prototype._scheduleRecv = function() {\n    var that = this;\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\n    var msg_counter = 0;\n    poll.onmessage = function(e) {\n        msg_counter += 1;\n        that.ri._didMessage(e.data);\n    };\n    poll.onclose = function(e) {\n        that.poll = poll = poll.onmessage = poll.onclose = null;\n        if (!that.poll_is_closing) {\n            if (e.reason === 'permanent') {\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\n            } else {\n                that._scheduleRecv();\n            }\n        }\n    };\n};\n\nPolling.prototype.abort = function() {\n    var that = this;\n    that.poll_is_closing = true;\n    if (that.poll) {\n        that.poll.abort();\n    }\n};\n//         [*] End of lib/trans-polling.js\n\n\n//         [*] Including lib/trans-receiver-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceReceiver = function(url) {\n    var that = this;\n    var es = new EventSource(url);\n    es.onmessage = function(e) {\n        that.dispatchEvent(new SimpleEvent('message',\n                                           {'data': unescape(e.data)}));\n    };\n    that.es_close = es.onerror = function(e, abort_reason) {\n        // ES on reconnection has readyState = 0 or 1.\n        // on network error it's CLOSED = 2\n        var reason = abort_reason ? 'user' :\n            (es.readyState !== 2 ? 'network' : 'permanent');\n        that.es_close = es.onmessage = es.onerror = null;\n        // EventSource reconnects automatically.\n        es.close();\n        es = null;\n        // Safari and chrome < 15 crash if we close window before\n        // waiting for ES cleanup. See:\n        //   https://code.google.com/p/chromium/issues/detail?id=89155\n        utils.delay(200, function() {\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n                    });\n    };\n};\n\nEventSourceReceiver.prototype = new REventTarget();\n\nEventSourceReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.es_close) {\n        that.es_close({}, true);\n    }\n};\n//         [*] End of lib/trans-receiver-eventsource.js\n\n\n//         [*] Including lib/trans-receiver-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar _is_ie_htmlfile_capable;\nvar isIeHtmlfileCapable = function() {\n    if (_is_ie_htmlfile_capable === undefined) {\n        if ('ActiveXObject' in _window) {\n            try {\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\n            } catch (x) {}\n        } else {\n            _is_ie_htmlfile_capable = false;\n        }\n    }\n    return _is_ie_htmlfile_capable;\n};\n\n\nvar HtmlfileReceiver = function(url) {\n    var that = this;\n    utils.polluteGlobalNamespace();\n\n    that.id = 'a' + utils.random_string(6, 26);\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +\n        'c=' + escape(WPrefix + '.' + that.id);\n\n    var constructor = isIeHtmlfileCapable() ?\n        utils.createHtmlfile : utils.createIframe;\n\n    var iframeObj;\n    _window[WPrefix][that.id] = {\n        start: function () {\n            iframeObj.loaded();\n        },\n        message: function (data) {\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));\n        },\n        stop: function () {\n            that.iframe_close({}, 'network');\n        }\n    };\n    that.iframe_close = function(e, abort_reason) {\n        iframeObj.cleanup();\n        that.iframe_close = iframeObj = null;\n        delete _window[WPrefix][that.id];\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));\n    };\n    iframeObj = constructor(url, function(e) {\n                                that.iframe_close({}, 'permanent');\n                            });\n};\n\nHtmlfileReceiver.prototype = new REventTarget();\n\nHtmlfileReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.iframe_close) {\n        that.iframe_close({}, 'user');\n    }\n};\n//         [*] End of lib/trans-receiver-htmlfile.js\n\n\n//         [*] Including lib/trans-receiver-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrReceiver = function(url, AjaxObject) {\n    var that = this;\n    var buf_pos = 0;\n\n    that.xo = new AjaxObject('POST', url, null);\n    that.xo.onchunk = function(status, text) {\n        if (status !== 200) return;\n        while (1) {\n            var buf = text.slice(buf_pos);\n            var p = buf.indexOf('\\n');\n            if (p === -1) break;\n            buf_pos += p+1;\n            var msg = buf.slice(0, p);\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));\n        }\n    };\n    that.xo.onfinish = function(status, text) {\n        that.xo.onchunk(status, text);\n        that.xo = null;\n        var reason = status === 200 ? 'network' : 'permanent';\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n    }\n};\n\nXhrReceiver.prototype = new REventTarget();\n\nXhrReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.xo) {\n        that.xo.close();\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));\n        that.xo = null;\n    }\n};\n//         [*] End of lib/trans-receiver-xhr.js\n\n\n//         [*] Including lib/test-hooks.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// For testing\nSockJS.getUtils = function(){\n    return utils;\n};\n\nSockJS.getIframeTransport = function(){\n    return IframeTransport;\n};\n//         [*] End of lib/test-hooks.js\n\n                  return SockJS;\n          })();\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);\n\n// AMD compliance\nif (typeof define === 'function' && define.amd) {\n    define('sockjs', [], function(){return SockJS;});\n}\n\nif (typeof module === 'object' && module && module.exports) {\n    module.exports = SockJS;\n}\n//     [*] End of lib/index.js\n\n// [*] End of lib/all.js\n\n\n//@ sourceURL=/node_modules/shoe/node_modules/sockjs-client/sockjs.js"
));

require.define("/inject.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar backoff = require('backoff')\n\nmodule.exports =\nfunction (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect\n    opts = opts || {initialDelay: 1e3, maxDelay: 30e3}\n    if(!onConnect)\n      onConnect = opts.onConnect\n\n    var emitter = new EventEmitter()\n    emitter.connected = false\n    emitter.reconnect = true\n\n    if(onConnect)\n      emitter.on('connect', onConnect)\n\n    var backoffMethod = (backoff[opts.type] || backoff.fibonacci) (opts)\n\n    backoffMethod.on('backoff', function (n, d) {\n      emitter.emit('backoff', n, d)\n    })\n\n    var args\n    function attempt (n, delay) {\n      if(emitter.connected) return\n      if(!emitter.reconnect) return\n\n      emitter.emit('reconnect', n, delay)\n      var con = createConnection.apply(null, args)\n      emitter._connection = con\n      \n      function onDisconnect () {\n        emitter.connected = false\n        con.removeListener('error', onDisconnect)\n        con.removeListener('close', onDisconnect)\n        con.removeListener('end'  , onDisconnect)\n\n        //hack to make http not crash.\n        //HTTP IS THE WORST PROTOCOL.\n        if(con.constructor.name == 'Request')\n          con.on('error', function () {})\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', con)\n\n        if(!emitter.reconnect) return\n        try { backoffMethod.backoff() } catch (_) { }\n      }\n\n      con\n        .on('error', onDisconnect)\n        .on('close', onDisconnect)\n        .on('end'  , onDisconnect)\n\n      if(con.constructor.name == 'Request') {\n        emitter.connected = true\n        emitter.emit('connect', con)\n        con.once('data', function () {\n          //this is the only way to know for sure that data is coming...\n          backoffMethod.reset()\n        })\n      } else {\n        con\n          .on('connect', function () {\n            backoffMethod.reset()\n            emitter.connected = true\n            con.removeListener('connect', onConnect)\n            emitter.emit('connect', con)\n          })\n      }\n    }\n\n    emitter.connect =\n    emitter.listen = function () {\n      this.reconnect = true\n      if(emitter.connected) return\n      backoffMethod.reset()\n      backoffMethod.on('ready', attempt)\n      args = args || [].slice.call(arguments)\n      attempt(0, 0)\n      return emitter\n    }\n\n    //force reconnection\n/*\n    emitter.reconnect = function () {\n      if(this.connected)\n        return emitter.disconnect()\n      \n      backoffMethod.reset()\n      attempt(0, 0)\n      return emitter\n    }\n*/\n    emitter.disconnect = function () {\n      this.reconnect = false\n      if(!emitter.connected) return emitter\n      \n      else if(emitter._connection)\n        emitter._connection.end()\n\n      emitter.emit('disconnect')\n      return emitter\n    }\n\n    var widget\n    emitter.widget = function () {\n      if(!widget)\n        widget = require('./widget')(emitter)\n      return widget\n    }\n\n    return emitter\n  }\n\n}\n\n//@ sourceURL=/inject.js"
));

require.define("/node_modules/backoff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/backoff/package.json"
));

require.define("/node_modules/backoff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar Backoff = require('./lib/backoff'),\n    FibonacciBackoffStrategy = require('./lib/strategy/fibonacci'),\n    ExponentialBackoffStrategy = require('./lib/strategy/exponential');\n\nmodule.exports.Backoff = Backoff;\nmodule.exports.FibonacciStrategy = FibonacciBackoffStrategy;\nmodule.exports.ExponentialStrategy = ExponentialBackoffStrategy;\n\n/**\n * Constructs a Fibonacci backoff.\n * @param options Fibonacci backoff strategy arguments.\n * @see FibonacciBackoffStrategy\n */\nmodule.exports.fibonacci = function(options) {\n    return new Backoff(new FibonacciBackoffStrategy(options));\n};\n\n/**\n * Constructs an exponential backoff.\n * @param options Exponential strategy arguments.\n * @see ExponentialBackoffStrategy\n */\nmodule.exports.exponential = function(options) {\n    return new Backoff(new ExponentialBackoffStrategy(options));\n};\n\n\n//@ sourceURL=/node_modules/backoff/index.js"
));

require.define("/node_modules/backoff/lib/backoff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\n/**\n * Backoff driver.\n * @param backoffStrategy Backoff delay generator/strategy.\n * @constructor\n */\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n/**\n * Starts a backoff operation.\n */\nBackoff.prototype.backoff = function() {\n    if (this.timeoutID_ !== -1) {\n        throw new Error('Backoff in progress.');\n    }\n\n    this.backoffDelay_ = this.backoffStrategy_.next();\n    this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n    this.emit('backoff', this.backoffNumber_, this.backoffDelay_);\n};\n\n/**\n * Backoff completion handler.\n * @private\n */\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_++, this.backoffDelay_);\n};\n\n/**\n * Stops any backoff operation and resets the backoff\n * delay to its inital value.\n */\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n\n\n//@ sourceURL=/node_modules/backoff/lib/backoff.js"
));

require.define("/node_modules/backoff/lib/strategy/fibonacci.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Fibonacci backoff strategy.\n * @extends BackoffStrategy\n */\nfunction FibonacciBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(FibonacciBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.next_ = function() {\n    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ += this.backoffDelay_;\n    this.backoffDelay_ = backoffDelay;\n    return backoffDelay;\n};\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.reset_ = function() {\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.backoffDelay_ = 0;\n};\n\nmodule.exports = FibonacciBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/backoff/lib/strategy/fibonacci.js"
));

require.define("/node_modules/backoff/lib/strategy/strategy.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Abstract class defining the skeleton for all backoff strategies.\n * @param options Backoff strategy options.\n * @param options.randomisationFactor The randomisation factor, must be between\n * 0 and 1.\n * @param options.initialDelay The backoff initial delay, in milliseconds.\n * @param options.maxDelay The backoff maximal delay, in milliseconds.\n * @constructor\n */\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n/**\n * Retrieves the maximal backoff delay.\n * @return The maximal backoff delay.\n */\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n/**\n * Retrieves the initial backoff delay.\n * @return The initial backoff delay.\n */\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n/**\n * Template method that computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n/**\n * Computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n/**\n * Template method that resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n/**\n * Resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n\n\n//@ sourceURL=/node_modules/backoff/lib/strategy/strategy.js"
));

require.define("/node_modules/backoff/lib/strategy/exponential.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Exponential backoff strategy.\n * @extends BackoffStrategy\n */\nfunction ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(ExponentialBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.next_ = function() {\n    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ = this.backoffDelay_ * 2;\n    return this.backoffDelay_;\n};\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.reset_ = function() {\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n};\n\nmodule.exports = ExponentialBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/backoff/lib/strategy/exponential.js"
));

require.define("/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar h = require('hyperscript')\nvar o = require('observable')\n//TODO make this just a small square that goes red/orange/green\n\nmodule.exports = function (emitter) {\n  var color = o(), count = o()\n  color('red'); count(' ')\n\n  var el = h('div', {\n    style: {\n      background: color,\n      width: '1em', height: '1em',\n      display: 'inline-block',\n      'text-align': 'center',\n      border: '1px solid black'\n    }, \n    onclick: function () {\n      emitter.connected \n        ? emitter.disconnect()\n        : emitter.connect()\n    }\n  },\n  count\n  )\n  var int\n  emitter.on('reconnect', function (n, d) {\n    var delay = Math.round(d / 1000) + 1\n    count(delay)\n    color('red')\n    clearInterval(int)\n    int = setInterval(function () {\n      count(delay > 0 ? --delay : 0)\n      color(delay ? 'red' :'orange')      \n    }, 1e3)\n  })\n  emitter.on('connect',   function () {\n    count(' ')\n    color('green')\n    clearInterval(int)\n  })\n  emitter.on('disconnect', function () {\n    //count('  ')\n    color('red')\n  })\n  return el\n}\n\n//@ sourceURL=/widget.js"
));

require.define("/node_modules/hyperscript/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/hyperscript/package.json"
));

require.define("/node_modules/hyperscript/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () {\n\nfunction h() {\n  var args = [].slice.call(arguments), e = null\n  function item (l) {\n    var r\n    function parseClass (string) {\n      var m = string.split(/([\\.#]?[a-zA-Z0-9_-]+)/)\n      m.forEach(function (v) {\n        var s = v.substring(1,v.length)\n        if(!v) return \n        if(!e)\n          e = document.createElement(v)\n        else if (v[0] === '.')\n          e.classList.add(s)\n        else if (v[0] === '#')\n          e.setAttribute('id', s)\n      })\n    }\n\n    if(l == null)\n      ;\n    else if('string' === typeof l) {\n      if(!e)\n        parseClass(l)\n      else\n        e.appendChild(r = document.createTextNode(l))\n    }\n    else if('number' === typeof l \n      || 'boolean' === typeof l\n      || l instanceof Date \n      || l instanceof RegExp ) {\n        e.appendChild(r = document.createTextNode(l.toString()))\n    }\n    //there might be a better way to handle this...\n    else if (Array.isArray(l))\n      l.forEach(item)\n    else if(l instanceof Node)\n      e.appendChild(r = l)\n    else if(l instanceof Text)\n      e.appendChild(r = l)\n    else if ('object' === typeof l) {\n      for (var k in l) {\n        if('function' === typeof l[k]) {\n          if(/^on\\w+/.test(k)) {\n            e.addEventListener(k.substring(2), l[k])\n          } else {\n            e[k] = l[k]()\n            l[k](function (v) {\n              e[k] = v\n            })\n          }\n        }\n        else if(k === 'style') {\n          for (var s in l[k]) (function(s, v) {\n            if('function' === typeof v) {\n              e.style.setProperty(s, v())\n              v(function (val) {\n                e.style.setProperty(s, val)\n              })\n            } else\n              e.style.setProperty(s, l[k][s])\n          })(s, l[k][s])\n        } else\n          e[k] = l[k]\n      }\n    } else if ('function' === typeof l) {\n      //assume it's an observable!\n      var v = l()\n      e.appendChild(r = v instanceof Node ? v : document.createTextNode(v))\n\n      l(function (v) {\n        if(v instanceof Node && r.parentElement)\n          r.parentElement.replaceChild(v, r), r = v\n        else\n          r.textContent = v\n      })\n      \n    }\n\n    return r\n  }\n  while(args.length)\n    item(args.shift())\n\n  return e\n}\n\nif(typeof module === 'object')\n module.exports = h\nelse\n  this.hyperscript = h\n})()\n\n//@ sourceURL=/node_modules/hyperscript/index.js"
));

require.define("/node_modules/observable/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/observable/package.json"
));

require.define("/node_modules/observable/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () {\n\n// bind a to b -- One Way Binding\nfunction bind1(a, b) {\n  a(b()); b(a)\n}\n//bind a to b and b to a -- Two Way Binding\nfunction bind2(a, b) {\n  b(a()); a(b); b(a);\n}\n\n//---util-funtions------\n\n//check if this call is a get.\nfunction isGet(val) {\n  return undefined === val\n}\n\n//check if this call is a set, else, it's a listen\nfunction isSet(val) {\n  return 'function' !== typeof val\n}\n\n//trigger all listeners\nfunction all(ary, val) {\n  for(var k in ary)\n    ary[k](val)\n}\n\n//remove a listener\nfunction remove(ary, item) {\n  delete ary[ary.indexOf(item)]\n}\n\n//register a listener\nfunction on(emitter, event, listener) {\n  (emitter.on || emitter.addEventListener)\n    .call(emitter, event, listener, false)\n}\n\nfunction off(emitter, event, listener) {\n  (emitter.removeListener || emitter.removeEventListener || emitter.off)\n    .call(emitter, event, listener, false)\n}\n\n//An observable that stores a value.\n\nfunction value () {\n  var _val, listeners = []\n  return function (val) {\n    return (\n      isGet(val) ? _val\n    : isSet(val) ? all(listeners, _val = val)\n    : (listeners.push(val), function () {\n        remove(listeners, val)\n      })\n  )}}\n  //^ if written in this style, always ends )}}\n\n/*\n##property\nobserve a property of an object, works with scuttlebutt.\ncould change this to work with backbone Model - but it would become ugly.\n*/\n\nfunction property (model, key) {\n  return function (val) {\n    return (\n      isGet(val) ? model.get(key) :\n      isSet(val) ? model.set(key, val) :\n      (on(model, 'change:'+key, val), function () {\n        off(model, 'change:'+key, val)\n      })\n    )}}\n\n/*\nnote the use of the elvis operator `?:` in chained else-if formation,\nand also the comma operator `,` which evaluates each part and then\nreturns the last value.\n\nonly 8 lines! that isn't much for what this baby can do!\n*/\n\nfunction transform (observable, down, up) {\n  return function (val) {\n    return (\n      isGet(val) ? down(observable())\n    : isSet(val) ? observable((up || down)(val))\n    : observable(function (_val) { val(down(_val)) })\n    )}}\n\nfunction not(observable) {\n  return transform(observable, function (v) { return !v })\n}\n\nfunction listen (element, event, attr, listener) {\n  function onEvent () {\n    listener('function' === typeof attr ? attr() : attr)\n  }\n  on(element, event, onEvent)\n  return function () {\n    off(element, event, onEvent)\n  }\n}\n\n//observe html element - aliased as `input`\nfunction attribute(element, attr, event) {\n  attr = attr || 'value'; event = event || 'input'\n  return function (val) {\n    return (\n      isGet(val) ? element[attr]\n    : isSet(val) ? element[attr] = val\n    : listen(element, event, attr, val)\n    )}\n}\n\n// observe a select element\nfunction select(element) {\n  function _attr () {\n      return element[element.selectedIndex].value;\n  }\n  function _set(val) {\n    for(var i=0; i < element.options.length; i++) {\n      if(element.options[i].value == val) element.selectedIndex = i;\n    }\n  }\n  return function (val) {\n    return (\n      isGet(val) ? element.options[element.selectedIndex].value\n    : isSet(val) ? _set(val)\n    : listen(element, 'change', _attr, val)\n    )}\n}\n\n//toggle based on an event, like mouseover, mouseout\nfunction toggle (el, up, down) {\n  var i = false\n  return function (val) {\n    function onUp() {\n      i || val(i = true)\n    }\n    function onDown () {\n      i && val(i = false)\n    }\n    return (\n      isGet(val) ? i\n    : isSet(val) ? undefined //read only\n    : (on(el, up, onUp), on(el, down || up, onDown), function () {\n      off(el, up, onUp); off(el, down || up, onDown)\n    })\n  )}}\n\nfunction error (message) {\n  throw new Error(message)\n}\n\nfunction compute (observables, compute) {\n  function getAll() {\n    return compute.apply(null, observables.map(function (e) {return e()}))\n  }\n  return function (val) {\n    return (\n      isGet(val) ? getAll()\n    : isSet(val) ? error('read-only')\n    : observables.forEach(function (obs) {\n        obs(function () { val(getAll()) })\n      })\n    )}}\n\nfunction boolean (observable, truthy, falsey) {\n  return transform(observable, function (val) {\n      return val ? truthy : falsey\n    }, function (val) {\n      return val == truthy ? true : false\n    })\n  }\n\nvar exports = value\nexports.bind1     = bind1\nexports.bind2     = bind2\nexports.value     = value\nexports.not       = not\nexports.property  = property\nexports.input     =\nexports.attribute = attribute\nexports.select    = select\nexports.compute   = compute\nexports.transform = transform\nexports.boolean   = boolean\nexports.toggle    = toggle\nexports.hover     = function (e) { return toggle(e, 'mouseover', 'mouseout')}\nexports.focus     = function (e) { return toggle(e, 'focus', 'blur')}\n\nif('object' === typeof module) module.exports = exports\nelse                           this.observable = exports\n})()\n\n//@ sourceURL=/node_modules/observable/index.js"
));

require.define("/examples/shoe/node_modules/domready/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./ready.js\"}\n//@ sourceURL=/examples/shoe/node_modules/domready/package.json"
));

require.define("/examples/shoe/node_modules/domready/ready.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n  * domready (c) Dustin Diaz 2012 - License MIT\n  */\n!function (name, definition) {\n  if (typeof module != 'undefined') module.exports = definition()\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)\n  else this[name] = definition()\n}('domready', function (ready) {\n\n  var fns = [], fn, f = false\n    , doc = document\n    , testEl = doc.documentElement\n    , hack = testEl.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , addEventListener = 'addEventListener'\n    , onreadystatechange = 'onreadystatechange'\n    , readyState = 'readyState'\n    , loaded = /^loade|c/.test(doc[readyState])\n\n  function flush(f) {\n    loaded = 1\n    while (f = fns.shift()) f()\n  }\n\n  doc[addEventListener] && doc[addEventListener](domContentLoaded, fn = function () {\n    doc.removeEventListener(domContentLoaded, fn, f)\n    flush()\n  }, f)\n\n\n  hack && doc.attachEvent(onreadystatechange, fn = function () {\n    if (/^c/.test(doc[readyState])) {\n      doc.detachEvent(onreadystatechange, fn)\n      flush()\n    }\n  })\n\n  return (ready = hack ?\n    function (fn) {\n      self != top ?\n        loaded ? fn() : fns.push(fn) :\n        function () {\n          try {\n            testEl.doScroll('left')\n          } catch (e) {\n            return setTimeout(function() { ready(fn) }, 50)\n          }\n          fn()\n        }()\n    } :\n    function (fn) {\n      loaded ? fn() : fns.push(fn)\n    })\n})\n//@ sourceURL=/examples/shoe/node_modules/domready/ready.js"
));

require.define("/examples/shoe/node_modules/event-stream/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/examples/shoe/node_modules/event-stream/package.json"
));

require.define("/examples/shoe/node_modules/event-stream/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n  , es = exports\n\nes.Stream = Stream //re-export Stream from core\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nes.through = function (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = (\n    'sync'== end || !end\n  //use sync end. (default)\n  ? function () { this.emit('end') }\n  : 'async' == end || end === true \n  //use async end.\n  //must eventually call drain if paused.\n  //else will not end.\n  ? function () {\n      if(!this.paused)\n        return this.emit('end')\n     var self = this\n     this.once('drain', function () {\n        self.emit('end')\n      })\n    }\n  //use custom end function\n  : end \n  )\n  var ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      stream.destroy()\n  })\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  /*\n    destroy is called on a writable stream when the upstream closes.\n    it's basically END but something has gone wrong.\n    I'm gonna emit 'close' and change then otherwise act as 'end'\n  */\n  stream.destroy = function () {\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    stream.paused = true\n  }\n  stream.resume = function () {\n    if(stream.paused)\n      stream.emit('drain')\n    stream.paused = false\n  }\n  return stream\n}\n\n// buffered\n//\n// same as a through stream, but won't emit a chunk until the next tick.\n// does not support any pausing. intended for testing purposes.\n\n// XXX: rewrite this. this is crap. but do I actually use it? maybe just throw it away?\n// okay, it's used in snob. so... throw this out and let snob use a legacy version. (fix later/never)\n\n\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  var stream = new Stream()\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  toMerge.forEach(function (e) {\n    e.pipe(stream, {end: false})\n    var ended = false\n    e.on('end', function () {\n      if(ended) return\n      ended = true\n      endCount ++\n      if(endCount == toMerge.length)\n        stream.emit('end') \n    })\n  })\n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n\n  return stream\n}\n\n\n// writable stream, collects all events into an array \n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = []\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n \n  stream.readable = true  \n  stream.writable = false\n \n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n  \n  stream.resume = function () {\n    paused = false\n    var l = array.length\n    while(i < l && !paused) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l)\n      stream.emit('end'), stream.readable = false\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\nes.readable = function (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true  \n  stream.writable = false\n \n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n  \n  stream.on('end', function () { ended = true })\n  \n  function get (err, data) {\n    \n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    process.nextTick(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)    \n      }\n    })\n  \n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('close')\n    stream.emit('end')\n    ended = true\n  }\n  return stream\n}\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nes.map = function (mapper) {\n  var stream = new Stream()\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n\n  stream.writable = true\n  stream.readable = true\n   \n  stream.write = function () {\n    if(ended) throw new Error('map stream is not writable')\n    inputs ++\n    var args = [].slice.call(arguments)\n      , r\n      , inNext = false \n    //pipe only allows one argument. so, do not \n    function next (err) {\n      if(destroyed) return\n      inNext = true\n      outputs ++\n      var args = [].slice.call(arguments)\n      if(err) {\n        args.unshift('error')\n        return inNext = false, stream.emit.apply(stream, args)\n      }\n      args.shift() //drop err\n      if (args.length){\n        args.unshift('data')\n        r = stream.emit.apply(stream, args)\n      }\n      if(inputs == outputs) {\n        if(paused) paused = false, stream.emit('drain') //written all the incoming events\n        if(ended)\n          stream.end()\n      }\n      inNext = false\n    }\n    args.push(next)\n    \n    try {\n      //catch sync errors and handle them like async errors\n      var written = mapper.apply(null, args)\n      if(written === false) paused = true\n      return written\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return true\n    }\n  }\n\n  stream.end = function () {\n    var args = [].slice.call(arguments)\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    if(args.length)\n      return stream.write.apply(emitter, args)\n    else if (inputs == outputs) //wait for processing\n      stream.emit('end')\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n  }\n\n  return stream\n}\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) { \n  return es.through(function write(data) {\n    var mappedData = sync(data)\n    if (typeof mappedData !== 'undefined')\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n//\n// combine multiple streams together so that they act as a single stream\n//\n\nes.pipe = es.connect = function () {\n\n  var streams = [].slice.call(arguments)\n    , first = streams[0]\n    , last = streams[streams.length - 1]\n    , thepipe = es.duplex(first, last)\n\n  if(streams.length == 1)\n    return streams[0]\n  else if (!streams.length)\n    throw new Error('connect called with empty args')\n\n  //pipe all the streams together\n\n  function recurse (streams) {\n    if(streams.length < 2)\n      return\n    streams[0].pipe(streams[1])\n    recurse(streams.slice(1))  \n  }\n  \n  recurse(streams)\n \n  function onerror () {\n    var args = [].slice.call(arguments)\n    args.unshift('error')\n    thepipe.emit.apply(thepipe, args)\n  }\n  \n  streams.forEach(function (stream) {\n    stream.on('error', onerror)\n  })\n\n  return thepipe\n}\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\n//\n// duplex -- pipe into one stream and out another\n//\n\nes.duplex = function (writer, reader) {\n  var thepipe = new Stream()\n\n  thepipe.__defineGetter__('writable', function () { return writer.writable })\n  thepipe.__defineGetter__('readable', function () { return reader.readable })\n\n  ;['write', 'end', 'close'].forEach(function (func) {\n    thepipe[func] = function () {\n      return writer[func].apply(writer, arguments)\n    }\n  })\n\n  ;['resume', 'pause'].forEach(function (func) {\n    thepipe[func] = function () { \n      thepipe.emit(func)\n      if(reader[func])\n        return reader[func].apply(reader, arguments)\n      else\n        reader.emit(func)\n    }\n  })\n\n  ;['data', 'close'].forEach(function (event) {\n    reader.on(event, function () {\n      var args = [].slice.call(arguments)\n      args.unshift(event)\n      thepipe.emit.apply(thepipe, args)\n    })\n  })\n  //only emit end once\n  var ended = false\n  reader.on('end', function () {\n    if(ended) return\n    ended = true\n    var args = [].slice.call(arguments)\n    args.unshift('end')\n    thepipe.emit.apply(thepipe, args)\n  })\n\n  thepipe.destroy = function () {\n    if(reader.destroy)\n      reader.destroy()\n    if(writer.destroy)\n      writer.destroy()\n  }\n\n  return thepipe\n}\n\nes.split = function (matcher) {\n  var soFar = ''\n  if (!matcher)\n    matcher = '\\n'\n\n  return es.through(function (buffer) { \n    var stream = this\n      , pieces = (soFar + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    pieces.forEach(function (piece) {\n      stream.emit('data', piece)\n    })\n\n    return true\n  },\n  function () {\n    if(soFar)\n      this.emit('data', soFar)  \n    this.emit('end')\n  })\n}\n\n//\n// gate \n//\n// while the gate is shut(), buffer incoming. \n// \n// if gate is open() stream like normal.\n//\n// currently, when opened, this will emit all data unless it is shut again\n// if downstream pauses it will still write, i'd like to make it respect pause, \n// but i'll need a test case first.\n\nes.gate = function (shut) {\n\n  var stream = new Stream()\n    , queue = []\n    , ended = false\n\n    shut = (shut === false ? false : true) //default to shut\n\n  stream.writable = true\n  stream.readable = true\n\n  stream.isShut = function () { return shut }\n  stream.shut   = function () { shut = true }\n  stream.open   = function () { shut = false; maybe() }\n  \n  function maybe () {\n    while(queue.length && !shut) {\n      var args = queue.shift()\n      args.unshift('data')\n      stream.emit.apply(stream, args)\n    }\n    stream.emit('drain')\n    if(ended && !shut) \n      stream.emit('end')\n  }\n  \n  stream.write = function () {\n    var args = [].slice.call(arguments)\n  \n    queue.push(args)\n    if (shut) return false //pause up stream pipes  \n\n    maybe()\n  }\n\n  stream.end = function () {\n    ended = true\n    if (!queue.length)\n      stream.emit('end')\n  }\n\n  return stream\n}\n\n//\n// parse\n//\n\nes.parse = function () { \n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      return console.error(err, 'attemping to parse:', data)\n    }\n    this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () { \n  return es.mapSync(function (e){\n    return JSON.stringify(e) + '\\n'\n  }) \n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join(). \n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.connect(es.split(from), es.join(to))\n} \n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n// \n\nes.join = function (str) {\n  \n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var stream = new Stream()\n  var first = true\n  stream.readable = stream.writable = true\n  stream.write = function (data) {\n    if(!first)\n      stream.emit('data', str)\n    first = false\n    stream.emit('data', data)\n    return true\n  }\n  stream.end = function (data) {\n    if(data)\n      this.write(data)\n    this.emit('end')\n  }\n  return stream\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var stream = new Stream()\n  var body = ''\n  stream.readable = true\n  stream.writable = true\n  stream.write = function (data) { body += data }\n  stream.end = function (data) {\n    if(data)\n      body += data\n    if(callback)\n      callback(null, body)\n    stream.emit('data', body)\n    stream.emit('end')\n  }\n  return stream\n}\n\n//\n// helper to make your module into a unix pipe\n// simply add \n// \n// if(!module.parent)\n//  require('event-stream').pipable(asyncFunctionOrStreams)\n// \n// asyncFunctionOrStreams may be one or more Streams or if it is a function, \n// it will be automatically wrapped in es.map\n//\n// then pipe stuff into from the command line!\n// \n// curl registry.npmjs.org/event-stream | node hello-pipeable.js | grep whatever\n//\n// etc!\n//\n// also, start pipeable running as a server!\n//\n// > node hello-pipeable.js --port 44444\n// \n\nvar setup = function (args) {\n  return args.map(function (f) {\n    var x = f()\n      if('function' === typeof x)\n        return es.map(x)\n      return x\n    })\n}\n\nes.pipeable = function () {\n  if(process.title != 'node')\n    return console.error('cannot use es.pipeable in the browser')\n  //(require) inside brackets to fool browserify, because this does not make sense in the browser.\n  var opts = (require)('optimist').argv\n  var args = [].slice.call(arguments)\n  \n  if(opts.h || opts.help) {\n    var name = process.argv[1]\n    console.error([\n      'Usage:',\n      '',\n      'node ' + name + ' [options]',\n      '  --port PORT        turn this stream into a server',\n      '  --host HOST        host of server (localhost is default)',\n      '  --protocol         protocol http|net will require(protocol).createServer(...',\n      '  --help             display this message',\n      '',\n      ' if --port is not set, will stream input from stdin',\n      '',\n      'also, pipe from or to files:',\n      '',\n      ' node '+name+ ' < file    #pipe from file into this stream',\n      ' node '+name+ ' < infile > outfile    #pipe from file into this stream',     \n      '',\n    ].join('\\n'))\n  \n  } else if (!opts.port) {\n    var streams = setup(args)\n    streams.unshift(es.split())\n    //streams.unshift()\n    streams.push(process.stdout)\n    var c = es.connect.apply(null, streams)\n    process.openStdin().pipe(c) //there\n    return c\n\n  } else {\n  \n    opts.host = opts.host || 'localhost'\n    opts.protocol = opts.protocol || 'http'\n    \n    var protocol = (require)(opts.protocol)\n        \n    var server = protocol.createServer(function (instream, outstream) {  \n      var streams = setup(args)\n      streams.unshift(es.split())\n      streams.unshift(instream)\n      streams.push(outstream || instream)\n      es.pipe.apply(null, streams)\n    })\n    \n    server.listen(opts.port, opts.host)\n\n    console.error(process.argv[1] +' is listening for \"' + opts.protocol + '\" on ' + opts.host + ':' + opts.port)  \n  }\n}\n\n//@ sourceURL=/examples/shoe/node_modules/event-stream/index.js"
));

require.define("/examples/shoe/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reconnect = require('../../');\nvar domready = require('domready');\nvar es = require('event-stream');\n\n//****************************************\n//* copy pasted from shoe/example/invert *\n//* but with automatic reconnection!     *\n//****************************************\n\ndomready(function () {\n    var result = document.getElementById('result');\n    \n    var r = reconnect(function (stream) {\n      var s = es.mapSync(function (msg) {\n          result.appendChild(document.createTextNode(msg));\n          return String(Number(msg)^1);\n      });\n      s.pipe(stream).pipe(s);\n\n    }).connect('/invert')\n\n    document.body.appendChild(r.widget())\n});\n\n//@ sourceURL=/examples/shoe/client.js"
));
require("/examples/shoe/client.js");
})();

